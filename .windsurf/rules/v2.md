---
trigger: always_on
---

This is included into the v2 which was then more polished onto the v3 architecture, Do note : ALL THE PLANS IN v1, v2 and v3 are valid and each is an iteration and improvement of the application, there is no need to break the existing setup as the current flow is an expansion also the more complex v3 plan in natural language exists on : C:\Users\Tecnots User\workspace\tecnots\Connector\Van_Sales_Unified_Architecture_v3.docx for further improvements


# Executive Summary: Mini Connector Architecture

## The Critical Update

**What We Missed:** The original architecture assumed all ERP systems would be internet-accessible with static IPs. In reality, 70% of SMB ERP systems are on-premise behind dynamic IPs and firewalls.

**The Solution:** Mini Connector - a lightweight on-premise agent that bridges local databases to the cloud console via outbound WebSocket connections.

---

## Key Architecture Changes

### Before (Original)

```
Cloud Console → (Direct Connection) → ERP Database
```

**Problems:**

- ❌ Requires static IP
- ❌ Requires firewall rules
- ❌ Not feasible for most SMBs

### After (Revised)

```
Cloud Console ← (Outbound WebSocket) ← Mini Connector → Local ERP
```

**Benefits:**

- ✅ No static IP needed
- ✅ No firewall configuration
- ✅ Credentials never leave premises
- ✅ Works with 99% of corporate networks

---

## Three-Component System

### 1. Cloud Console (SaaS)

- **Aggregator Marketplace:** Browse and install connectors (Vansales, Salesforce, Snowflake, etc.)
- **Workflow Designer:** Drag-and-drop workflow creation
- **AI SDK Generator:** Auto-generate SDKs from documentation
- **WebSocket Gateway:** Persistent connections to mini connectors
- **Temporary Data Buffer:** Encrypted, auto-purging data storage (24h TTL)

### 2. Mini Connector (On-Premise)

- **Installation:** Single .exe/.zip download per company
- **Configuration:** Simple CLI wizard
- **Connection:** Outbound WebSocket to cloud (firewall-friendly)
- **Credentials:** Stored locally, encrypted, never transmitted
- **Execution:** Runs queries locally, enforces READ-ONLY
- **API Key:** One key per connector instance (no reuse)

### 3. Target Systems (On-Premise)

- Local ERP systems (SAP, Tally, Oracle)
- Local databases (MySQL, PostgreSQL, SQL Server)
- Accessible via localhost or local network IPs

---

## Data Flow Example

### Scenario: Salesforce → Local MySQL

```
1. User creates workflow in Cloud Console
   Source: Salesforce (cloud)
   Destination: MySQL (mini connector)

2. Workflow execution:
   [Cloud] Extract from Salesforce (direct API call)
   ↓
   [Cloud Buffer] Store data (encrypted, 24h TTL)
   ↓
   [Cloud] Send command via WebSocket to Mini Connector
   ↓
   [Mini Connector] Receive command
   ↓
   [Mini Connector] Fetch data from buffer (HTTPS)
   ↓
   [Mini Connector] Execute INSERT in local MySQL
   ↓
   [Mini Connector] Send result to cloud
   ↓
   [Cloud] Mark workflow complete
   ↓
   [Cloud Buffer] Auto-purge after 24h
```

---

## Security Model

### Multi-Layer READ-ONLY Enforcement

**Boss Requirement:** "Even with root credentials, enforce READ-ONLY mode"

**Implementation:**

1. **AI Layer:** Generate only SELECT queries
2. **WASM Layer:** Block write operations at runtime
3. **Mini Connector Layer:** Validate all queries before execution
4. **Database Layer:** Use read-only user (recommended best practice)

### Credential Isolation

**Critical:** Database credentials NEVER leave the on-premise network

```
Cloud Console:
- ❌ NO database passwords stored
- ❌ NO connection strings
- ✅ Only API keys (for mini connector auth)

Mini Connector:
- ✅ Database credentials stored locally
- ✅ Encrypted with machine-specific key
- ✅ Decrypted only in memory during execution
- ✅ Never transmitted to cloud
```

### API Key Security

**Format:** `vmc_<tenant>_<random>_<checksum>`  
**Example:** `vmc_abc123_x7f9k2p5w8q1_c4e2a`

**Rules:**

- One API key per mini connector instance
- Attempt to use same key twice = Error
- Keys can be revoked instantly (emergency)
- Hash stored in cloud (not plaintext)

---

## WebSocket Protocol

### Why WebSocket?

|Method|Firewall-Friendly|Real-Time|Efficient|Decision|
|---|---|---|---|---|
|HTTP Polling|✅|❌|❌|❌|
|Long Polling|✅|⚠️|⚠️|❌|
|**WebSocket (Outbound)**|✅|✅|✅|✅ **CHOSEN**|
|Inbound Connections|❌|✅|✅|❌ Not feasible|

**Key Points:**

- Mini connector initiates connection (outbound from firewall perspective)
- Persistent connection (low latency)
- Bidirectional (cloud sends commands, mini connector streams results)
- Standard protocol (well-supported)
- Works through corporate proxies

### Connection Lifecycle

```go
1. Mini Connector starts
2. Reads API key from config
3. Establishes WebSocket connection: wss://connector.vansales.com
4. Cloud validates API key
5. Cloud checks for duplicate (reject if already connected)
6. Cloud registers connection
7. Mini Connector sends heartbeat every 30s
8. Cloud sends commands as needed
9. Mini Connector executes and returns results
10. Auto-reconnect if connection drops
```

---

## Aggregator Marketplace

### Concept

**User View:** Browse and install connectors like an app store

**Examples:**

- **Vansales Connector** (mini connector) - On-premise ERP/DB
- **Salesforce API** (cloud) - CRM data
- **Snowflake** (cloud) - Data warehouse
- **Custom Connector** (either) - Customer-provided docs

### Installation Flow

**For Cloud Aggregators (e.g., Salesforce):**

```
1. Click "Install Salesforce"
2. Enter API credentials
3. Click "Test Connection"
4. Ready to use in workflows
```

**For On-Premise Aggregators (e.g., Vansales):**

```
1. Click "Install Vansales Connector"
2. Get API key: vmc_abc123_...
3. Download mini-connector.exe
4. Run on server with ERP access
5. Configure with API key + DB credentials
6. Mini connector connects to cloud
7. Cloud auto-discovers schema
8. Ready to use in workflows
```

---

## AI SDK Generator

### Documentation-to-SDK Pipeline

**Input:** URL of API documentation or database type  
**Output:** Production-ready TypeScript SDK (compiled to WASM)

**Steps:**

1. AI reads documentation
2. AI extracts operations, schemas, auth methods
3. AI generates TypeScript SDK code
4. System injects READ-ONLY enforcement (if on-premise)
5. Security scanner validates code
6. Compiler produces WASM binary
7. Test suite validates functionality
8. SDK registered in marketplace

**Example:**

```
User: "Add aggregator from https://api.example.com/docs"

AI: *reads docs*
    Found 15 endpoints
    Authentication: OAuth 2.0
    Capabilities: read, write, bulk, webhooks
    
    Generated SDK with operations:
    - getCustomers()
    - createOrder()
    - updateInventory()
    ...

Cloud: SDK ready! You can now use this in workflows.
```

---

## Schema Discovery

### Auto-Discovery Process

**Goal:** Understand on-premise database structure automatically

**How:**

1. Mini connector connects to cloud
2. Cloud sends "discover_schema" command
3. Mini connector queries INFORMATION_SCHEMA (MySQL/PostgreSQL) or system tables (SAP)
4. Mini connector sends table/column metadata to cloud
5. Cloud stores schema in registry
6. AI uses schema for smart workflow suggestions

**User Experience:**

```
Before:
- User manually types table names
- User manually types column names
- Prone to typos
- Takes 30 minutes

After:
- Console: "I found 15 tables in your database"
- Console: "Your 'customers' table has email addresses"
- Console: "Would you like to sync to Mailchimp?"
- Takes 2 minutes
```

---

## Implementation Timeline

### Phase 1: Foundation + Mini Connector (Months 1-3)

**Month 1: Cloud Infrastructure**

- Monorepo setup
- Database schema
- Tenant management
- WebSocket gateway (basic)
- API key generation

**Month 2: Mini Connector Development**

- Core application (Go or Node.js)
- WebSocket client
- Local credential vault
- Query executor
- READ-ONLY enforcement
- Configuration CLI

**Month 3: Data Buffer + Integration**

- S3-based buffer
- Encryption service
- Auto-purge mechanism
- End-to-end test: Salesforce → Mini Connector → MySQL

**Milestone:** Working mini connector, can sync cloud → on-premise

---

### Phase 2: AI SDK Generator (Months 4-5)

**Month 4: Documentation Parser**

- AI documentation parser (Claude)
- Schema extraction
- TypeScript SDK generation
- WASM compilation

**Month 5: Aggregator Marketplace**

- Marketplace UI
- Aggregator listing
- Installation flow
- Schema discovery integration
- AI workflow suggestions

**Milestone:** Can generate SDK from any API documentation

---

### Phase 3: Production UI (Months 6-7)

**Month 6: Workflow Designer**

- React Flow-based designer
- Drag-and-drop activities
- Aggregator selection
- Real-time validation

**Month 7: Monitoring Dashboard**

- Execution list/detail
- Mini connector status
- Error explorer
- Control panel (pause/cancel/resume)

**Milestone:** Full user-facing product ready for beta

---

### Phase 4: Production Hardening (Months 8-9)

**Month 8: Security & Compliance**

- Penetration testing
- SAST/DAST in CI/CD
- SOC 2 Type II prep
- Audit logging
- Incident response plan

**Month 9: Observability & Operations**

- Prometheus + Grafana
- OpenTelemetry tracing
- Control flags UI
- Health checks
- Disaster recovery

**Milestone:** Production-ready, secure, observable

---

### Phase 5: Scale & Polish (Months 10-12)

**Month 10: Performance**

- Load testing (10K workflows/day)
- Database optimization
- WebSocket clustering
- Worker autoscaling

**Month 11: Enterprise Features**

- Multi-region support
- Custom aggregators
- Advanced transformations
- Workflow templates

**Month 12: Launch**

- Beta testing (10 customers)
- Documentation
- Video tutorials
- General availability

**Milestone:** Public launch

---

## Technology Decisions

### Cloud Console

- **Language:** TypeScript
- **Backend:** NestJS (Node.js)
- **Database:** PostgreSQL 15+
- **Cache:** Redis 7+
- **Queue:** BullMQ → Temporal (migration path)
- **Frontend:** React 18 + React Flow
- **AI:** Anthropic Claude Sonnet 4

### Mini Connector

- **MVP:** Node.js (TypeScript) - same as cloud
- **Production:** Go - single binary, no runtime needed
- **Database Support:** MySQL, PostgreSQL, SQL Server (Phase 1)
- **Packaging:** .exe (Windows), binary (Linux), .app (macOS)

### Why Go for Mini Connector?

- ✅ Single ~10MB binary (no runtime installation)
- ✅ Cross-platform compilation
- ✅ Excellent WebSocket libraries
- ✅ Fast execution
- ✅ Small memory footprint

**Build Commands:**

```bash
GOOS=windows GOARCH=amd64 go build -o mini-connector.exe
GOOS=linux GOARCH=amd64 go build -o mini-connector
GOOS=darwin GOARCH=amd64 go build -o mini-connector
```

---

## Risks & Mitigations

### Technical Risks

|Risk|Mitigation|
|---|---|
|WebSocket scalability|Cluster mode + Redis pub/sub|
|Mini connector offline|Command queuing + retry logic|
|Network instability|Exponential backoff + reconnection|
|Firewall blocks WebSocket|HTTP tunneling + documentation|
|READ-ONLY bypass|Multi-layer enforcement + audit log|

### Business Risks

|Risk|Mitigation|
|---|---|
|Customers don't trust cloud|Emphasize credentials never leave premises|
|Installation friction|One-click installer + video guide|
|Slow adoption|Free tier + excellent docs|
|Competition (Zapier)|Differentiation: AI + ERP-focus + on-premise|

### Security Risks

|Risk|Mitigation|
|---|---|
|Credential theft|Encrypted vault + machine-specific key|
|Man-in-the-middle|TLS 1.3 only + certificate pinning|
|Malicious binary|Code signing + checksum verification|
|Data breach|Encryption at rest + 24h TTL + access control|

---

## Success Metrics

### MVP (Month 6)

- ✅ 5 beta customers using mini connector
- ✅ 3 database types supported
- ✅ 10 workflows running in production
- ✅ 99% uptime
- ✅ <5s command latency

### Production (Month 12)

- ✅ 50 paying customers
- ✅ 5000+ mini connectors deployed
- ✅ 10,000 workflows/day
- ✅ 99.9% uptime
- ✅ 5 ERP types supported
- ✅ SOC 2 Type II certified

### Scale (Month 18)

- ✅ 200+ customers
- ✅ 50,000+ mini connectors
- ✅ 100,000+ workflows/day
- ✅ Multi-region deployment
- ✅ 20+ ERP types supported

---

## Competitive Advantages

### vs. Zapier

- ✅ AI-powered SDK generation (no manual connector building)
- ✅ On-premise support (mini connector)
- ✅ ERP-focused (not generic integrations)

### vs. Airbyte

- ✅ No-code workflow designer (not just data pipelines)
- ✅ AI assistance (schema discovery, suggestions)
- ✅ Simpler on-premise deployment

### vs. Segment

- ✅ Bidirectional sync (not just cloud → warehouse)
- ✅ On-premise support
- ✅ Broader integrations (not just analytics)

---

## Next Steps

### Immediate (Week 1)

1. ✅ Review revised architecture
2. ✅ Approve technology choices
3. ✅ Confirm mini connector approach
4. ✅ Set up project repository

### Short-term (Month 1)

1. ✅ Build cloud infrastructure
2. ✅ Implement WebSocket gateway
3. ✅ Create API key system
4. ✅ Start mini connector development

### Medium-term (Months 2-6)

1. ✅ Complete mini connector MVP
2. ✅ Build AI SDK generator
3. ✅ Develop workflow designer
4. ✅ Beta testing with 5 customers

### Long-term (Months 7-12)

1. ✅ Production hardening
2. ✅ Security compliance (SOC 2)
3. ✅ Performance optimization
4. ✅ General availability launch

---

## Questions & Answers

**Q: Why not use HTTP polling instead of WebSocket?**  
A: WebSocket provides real-time communication with lower latency. Polling would be inefficient and slow.

**Q: What if customer's firewall blocks WebSocket?**  
A: WebSocket uses standard HTTPS (port 443), which works in 99% of corporate networks. We also support HTTP tunneling as fallback.

**Q: How do we prevent API key sharing?**  
A: Cloud rejects duplicate connections. Only one mini connector can connect per API key at a time.

**Q: What if mini connector goes offline during workflow?**  
A: Commands are queued. When mini connector reconnects, it processes queued commands.

**Q: How do we ensure database credentials are safe?**  
A: Credentials never leave the on-premise network. They're encrypted locally with machine-specific key.

**Q: Can customers write to their database?**  
A: By default, no (READ-ONLY enforced). For trusted customers, we can enable writes via separate API endpoints with extensive logging.

**Q: What databases are supported?**  
A: Phase 1: MySQL, PostgreSQL, SQL Server. Phase 2: Oracle, SAP HANA, MongoDB. Phase 3: Tally, custom ODBC.

**Q: How does schema discovery work?**  
A: Mini connector queries INFORMATION_SCHEMA or system tables and sends metadata to cloud.

**Q: What if AI generates insecure code?**  
A: Multi-layer protection: security scanner, WASM sandbox, READ-ONLY enforcement, audit logging.

**Q: How long is data kept in buffer?**  
A: Maximum 24 hours, then auto-purged. Encrypted at rest.

---

## Summary

**The Core Innovation:** Mini Connector bridges the gap between cloud SaaS and on-premise ERP systems, making integration possible for the 70% of businesses whose systems aren't internet-accessible.

**Key Differentiators:**

1. AI-powered SDK generation (no manual coding)
2. Firewall-friendly (outbound WebSocket)
3. Secure by design (credentials never leave premises)
4. Simple installation (single .exe download)
5. Automatic schema discovery (2-minute setup)

**Estimated Timeline:** 12 months from start to general availability

**Total Effort:** ~6 engineers for 12 months

**Market Opportunity:** Millions of SMBs with on-premise ERP systems needing cloud integration

---

**Document Version:** 2.0  
**Last Updated:** January 29, 2026  
**Status:** Ready for Leadership Approval