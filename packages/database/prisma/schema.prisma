generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// CORE TENANT MANAGEMENT
// ============================================

model Tenant {
  id        String   @id @default(uuid())
  name      String
  tier      TenantTier @default(FREE)
  status    TenantStatus @default(ACTIVE)
  
  // Resource quotas
  maxConcurrentWorkflows Int @default(5)
  maxJobsPerHour        Int @default(100)
  maxConcurrentJobs     Int @default(2)
  maxStorageGB          Int @default(1)
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  users               User[]
  workflows           WorkflowDefinition[]
  aggregators         Aggregator[]
  aggregatorInstances AggregatorInstance[]
  connectors          Connector[]
  credentials         TenantCredential[]
  executions          WorkflowExecution[]
  controlFlags        SystemControlFlag[]
  fieldMappings       FieldMapping[]
  
  @@index([tier, status])
  @@map("tenants")
}

model User {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  email     String
  password  String   // Hashed
  name      String
  role      UserRole @default(ADMIN)
  
  // Refresh tokens
  refreshTokens RefreshToken[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([tenantId, email])
  @@index([tenantId])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@map("refresh_tokens")
}

// ============================================
// WORKFLOW SYSTEM
// ============================================

model WorkflowDefinition {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // Versioning
  version   Int      @default(1)
  hash      String   // SHA-256 of definition
  
  name        String
  description String?
  definition  Json   // Full workflow definition (nodes, connections, schedule)
  
  status    WorkflowStatus @default(DRAFT)
  
  // Lifecycle
  deprecatedAfter   DateTime?
  forceCancelAfter  DateTime?
  
  // Requirements for execution
  requiredSDKVersion   Int?
  requiredCapabilities String[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  executions WorkflowExecution[]
  
  @@unique([id, version])
  @@unique([tenantId, id, version])
  @@index([tenantId, status])
  @@map("workflow_definitions")
}

model WorkflowExecution {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  workflowId      String
  workflowVersion Int
  workflow        WorkflowDefinition @relation(fields: [workflowId, workflowVersion], references: [id, version])
  workflowHash    String   // Snapshot of hash at execution time
  
  status      ExecutionStatus @default(PENDING)
  currentStep String?
  
  // State reference (stored in S3/MinIO)
  stateSnapshotRef String?
  
  startedAt   DateTime @default(now())
  completedAt DateTime?
  
  // Relations
  activities  ActivityExecution[]
  events      ExecutionEvent[]
  
  @@index([tenantId, status])
  @@index([tenantId, startedAt])
  @@index([workflowId, workflowVersion])
  @@map("workflow_executions")
}

model ActivityExecution {
  id        String   @id @default(uuid())
  tenantId  String
  
  executionId String
  execution   WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  
  activityId  String   // Reference to activity in workflow definition
  activityType String // extract, transform, load, multi-extract, multi-load, sync, filter, join
  attempt     Int      @default(1)
  
  status      ActivityStatus @default(PENDING)
  
  // Aggregator instance references for tracking
  sourceInstanceId      String?
  sourceInstance        AggregatorInstance? @relation(name: "SourceInstance", fields: [sourceInstanceId], references: [id])
  
  destinationInstanceId String?
  destinationInstance   AggregatorInstance? @relation(name: "DestinationInstance", fields: [destinationInstanceId], references: [id])
  
  // Output stored in S3, versioned per attempt
  outputRef   String?
  
  errorMessage   String?
  errorRetryable Boolean?
  
  // Idempotency key used for this execution
  idempotencyKey String?
  
  startedAt   DateTime @default(now())
  completedAt DateTime?
  
  @@unique([executionId, activityId, attempt])
  @@index([executionId, status])
  @@index([tenantId, startedAt])
  @@index([sourceInstanceId])
  @@index([destinationInstanceId])
  @@map("activity_executions")
}

model ExecutionEvent {
  id          String   @id @default(uuid())
  
  executionId String
  execution   WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  
  timestamp   DateTime @default(now())
  eventType   String   // ACTIVITY_STARTED, ACTIVITY_COMPLETED, ACTIVITY_FAILED, STATE_SAVED, etc.
  payload     Json?
  
  // For tamper-proof audit trail
  previousHash String?
  signature    String?
  
  @@index([executionId, timestamp])
  @@map("execution_events")
}

// ============================================
// AGGREGATOR SYSTEM (Type + Instance Model)
// ============================================

// Aggregator = The SDK/type definition (MySQL, PostgreSQL, Salesforce)
model Aggregator {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  name        String           // "MySQL Connector"
  description String?
  category    String
  logoUrl     String?
  
  // Type classification
  type        AggregatorType @default(CLOUD)
  version     String   @default("1.0.0")
  
  // Capabilities: read, write, bulk, streaming, multi-table, etc.
  capabilities String[]
  
  // Auth methods supported
  authMethods  String[]
  
  // Configuration schema for dynamic form generation
  configSchema Json?    // { authType, fields: [...], oauthConfig: {...} }
  
  documentationUrl String?
  
  isPublic    Boolean  @default(false)  // false = private to tenant
  
  // SDK reference (WASM or code)
  sdkRef      String?
  sdkVersion  Int      @default(1)
  
  // API credentials for SDK execution (stored encrypted in production)
  // { baseUrl: string, apiKey?: string, bearerToken?: string }
  credentials Json?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  instances   AggregatorInstance[]
  
  @@index([tenantId])
  @@index([tenantId, category])
  @@map("aggregators")
}

// AggregatorInstance = A configured instance with specific credentials
model AggregatorInstance {
  id            String   @id @default(uuid())
  tenantId      String
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // Parent aggregator (the type/SDK)
  aggregatorId  String
  aggregator    Aggregator @relation(fields: [aggregatorId], references: [id], onDelete: Cascade)
  
  // Instance configuration
  name          String           // "Production MySQL"
  description   String?
  
  // Credentials stored securely in Vault (reference only)
  credentialId  String?
  credential    TenantCredential? @relation(fields: [credentialId], references: [id])
  
  // Connector assignment: NULL = Cloud Connector, "conn-xxx" = Mini Connector
  connectorId   String?
  connector     Connector? @relation(fields: [connectorId], references: [id])
  
  // Connection parameters (non-sensitive)
  connectionParams Json?         // { host: "db.example.com", port: 3306, database: "prod" }
  
  // Schema cache (discovered tables/columns)
  discoveredSchema Json?          // { tables: [...], relationships: [...] }
  schemaDiscoveredAt DateTime?
  
  // Status
  status        InstanceStatus   @default(ACTIVE)
  lastUsedAt    DateTime?
  
  // Sync tracking
  lastSyncAt    DateTime?
  
  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  sourceActivities      ActivityExecution[] @relation(name: "SourceInstance")
  destinationActivities ActivityExecution[] @relation(name: "DestinationInstance")
  sourceMappings        FieldMapping[] @relation(name: "MappingSource")
  destinationMappings   FieldMapping[] @relation(name: "MappingDestination")
  
  @@unique([tenantId, name])
  @@index([tenantId, aggregatorId])
  @@index([tenantId, connectorId])
  @@index([tenantId, status])
  @@map("aggregator_instances")
}

// ============================================
// CONNECTOR SYSTEM (Cloud + Mini)
// ============================================

model Connector {
  id            String   @id @default(uuid())
  tenantId      String
  tenant        Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  type          ConnectorType @default(CLOUD)
  name          String        // "Office Server Mini" or "Cloud Pool A"
  
  // For Mini Connector authentication
  apiKeyHash    String?       // bcrypt hash of API key
  apiKeyPrefix  String?       // First 8 chars for identification (e.g., "vmc_ab12")
  
  // Connection state
  status        ConnectorStatus @default(OFFLINE)
  lastHeartbeat DateTime?
  
  // System info (last reported, for Mini Connectors)
  ipAddress     String?
  hostname      String?
  version       String?
  os            String?
  
  // Resource reporting
  cpuUsage      Int?          // 0-100
  memoryUsage   Int?          // MB
  maxConcurrentJobs Int?      @default(5)
  
  // Capabilities advertised by connector
  supportedAggregators String[] // ["mysql", "postgresql", "mssql"]
  networkAccess   NetworkAccessType @default(LOCAL)
  
  // Command queue for offline connectors
  pendingCommands Json?         @default("[]") // Queue of commands to process when online
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  instances     AggregatorInstance[]
  
  @@index([tenantId, status])
  @@index([apiKeyHash])
  @@index([tenantId, type])
  @@map("connectors")
}

// ============================================
// CREDENTIAL MANAGEMENT (Vault Integration)
// ============================================

model TenantCredential {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  name        String   // "Production MySQL"
  description String?
  
  // Vault reference (actual secrets stored in HashiCorp Vault)
  vaultPath   String   // e.g., "/secret/tenants/{tenantId}/mysql-prod"
  vaultKeyId  String?  // Specific key version for rotation tracking
  
  // Credential type
  credentialType CredentialType @default(DATABASE)
  
  // Non-sensitive metadata for UI display
  host        String?  // e.g., "db.example.com"
  port        Int?     // e.g., 3306
  database    String?  // e.g., "production"
  usernameHint String? // e.g., "db_user" (partial for identification)
  
  // Rotation tracking
  lastRotatedAt DateTime?
  expiresAt     DateTime?
  
  // Audit
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  instances   AggregatorInstance[]
  
  @@unique([tenantId, name])
  @@index([tenantId, credentialType])
  @@map("tenant_credentials")
}

// ============================================
// SYSTEM CONTROL FLAGS (Kill Switches)
// ============================================

model SystemControlFlag {
  id          String   @id @default(uuid())
  
  // Scope: global, tenant, workflow, sdk, connector
  scope       ControlScope
  scopeId     String?  // tenantId, workflowId, etc. (NULL for global)
  
  tenantId    String?  // If tenant-scoped
  tenant      Tenant?  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  flagType    ControlFlagType
  enabled     Boolean  @default(true)
  
  // Metadata
  reason      String?  // Why this flag was set
  setBy       String   // User ID who set it
  
  // Auto-expiration
  expiresAt   DateTime?
  
  createdAt   DateTime @default(now())
  
  @@index([scope, scopeId, enabled])
  @@index([tenantId, enabled])
  @@index([expiresAt])
  @@map("system_control_flags")
}

// ============================================
// FIELD MAPPINGS
// ============================================

// Field Mapping = AI-generated or manual field mappings between data sources
model FieldMapping {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  name        String
  description String?
  
  // Mapping type classification
  type        MappingType @default(COLUMN)
  
  // Source configuration
  sourceInstanceId    String?
  sourceInstance      AggregatorInstance? @relation(name: "MappingSource", fields: [sourceInstanceId], references: [id], onDelete: SetNull)
  sourceType          String    // "database", "sdk", "aggregator", "mini-connector"
  sourceConnectorId   String?   // For mini-connector sources
  sourceName          String    // Table name, endpoint name, or object name
  sourceSchema        Json      // Discovered/parsed schema structure
  
  // Destination configuration
  destinationInstanceId   String?
  destinationInstance     AggregatorInstance? @relation(name: "MappingDestination", fields: [destinationInstanceId], references: [id], onDelete: SetNull)
  destinationType         String  // "database", "sdk", "aggregator", "mini-connector"
  destinationConnectorId  String? // For mini-connector destinations
  destinationName         String  // Table name, endpoint name, or object name
  destinationSchema       Json    // Target schema structure
  
  // AI-generated mapping rules
  // Format: [{ sourceField, destinationField, transform, transformConfig, nullable, dataType }]
  mappingRules        Json
  
  // Transformation code (for complex transformations)
  transformCode       String?
  
  // Metadata
  version             Int      @default(1)
  isActive            Boolean  @default(true)
  isGenerated         Boolean  @default(false)  // true if AI-generated
  lastUsedAt          DateTime?
  
  // Validation status
  isValidated         Boolean  @default(false)
  validationErrors    Json?    // Array of validation issues
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@unique([tenantId, name])
  @@index([tenantId, sourceInstanceId])
  @@index([tenantId, destinationInstanceId])
  @@index([tenantId, type])
  @@index([tenantId, isActive])
  @@map("field_mappings")
}

// ============================================
// ENHANCED ENUMS
// ============================================

enum MappingType {
  COLUMN          // Simple column-to-column mapping
  FIELD           // API field mapping (SDK)
  TRANSFORM       // Complex transformation mapping
  AGGREGATOR      // Aggregator-specific mapping (e.g., Salesforce objects)
  MINI_CONNECTOR  // Mini connector to cloud/SDK mapping
  HYBRID          // Mixed source types
}

enum TenantTier {
  FREE
  STANDARD
  ENTERPRISE
}

enum TenantStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

enum UserRole {
  ADMIN
  MEMBER
  VIEWER
}

enum WorkflowStatus {
  DRAFT
  ACTIVE
  DEPRECATED
  ARCHIVED
}

enum ExecutionStatus {
  PENDING
  RUNNING
  PAUSED
  CANCELLING
  COMPLETED
  FAILED
  CANCELLED
}

enum ActivityStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  TIMEOUT
}

enum AggregatorType {
  CLOUD
  ON_PREMISE
  HYBRID
}

enum InstanceStatus {
  ACTIVE
  INACTIVE
  ERROR
  CONNECTING
  SYNCING
}

enum ConnectorType {
  CLOUD
  MINI
}

enum ConnectorStatus {
  ONLINE
  OFFLINE
  CONNECTING
  ERROR
  BUSY
}

enum NetworkAccessType {
  LOCAL       // Localhost/local network only
  VPN         // VPN-accessible
  INTERNET    // Public internet
}

enum CredentialType {
  DATABASE
  API_KEY
  OAUTH
  BASIC_AUTH
  SSH_KEY
}

enum ControlScope {
  GLOBAL
  TENANT
  WORKFLOW
  SDK
  CONNECTOR
}

enum ControlFlagType {
  PAUSE       // Pause new executions
  BLOCK       // Block completely
  RATE_LIMIT  // Reduce rate limits
  READONLY    // Read-only mode
  EMERGENCY   // Emergency stop
}
